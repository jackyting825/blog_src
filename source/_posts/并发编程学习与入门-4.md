---
title: 并发编程学习与入门-4
date: 2020-04-06 20:21:28
tags:
  - java
---

> 线程安全策略

#### 不可变对象

不可变对象需要满足的条件

    1.对象创建以后其状态就不能修改
    2.对象所有域都是final类型
    3.对象是正确创建的(在对象创建期间,this引用没有逸出)

final 关键字:类,方法,变量

    修饰类:不能被继承
    修饰方法:1.锁定方法不被继承类修改;2.提升运行效率(针对于早期版本jdk)
    修饰变量:修饰数据类型变量(一旦初始化便不能修改),引用类型变量(初始化之后不能再指向另外一个对象)

声明不可变对象相关的集合类

Collections.unmodifiableXXX:Collection,List,Set...

Guava:ImmutableXXX:Collection,List,Set...

#### 线程封闭

线程封闭的几种实现方式

##### Ad-hoc 线程封闭:程序控制实现,最糟糕的方式,忽略

##### 堆栈封闭:简单来说就是局部变量,无并发问题

##### ThreadLocal 线程封闭:特别好的封闭方法

#### 常见的线程不安全类与写法

StringBuilder -> StringBuffer

SimpleDateForamt -> Joda-Time

ArrayList,HashSet,HashMap 等 Collections

先检查在执行:if(condition(a)){handle(a);}触发线程不安全

#### 同步容器,并不能完全的确保线程安全

ArrayList -> Vector,Stack

HashMap -> HashTable(key value 不能为 null)

Collections.synchronizedXXX(List,Set,Map)

#### 并发容器 J.U.C

ArrayList ->CopyOnWriteArrayList

HashSet,TreeSet -> CopyOnWriteArraySet,ConcurrentSkipListSet (只能保证单一操作原子性,如 add,remove 是线程安全的,不能保证批量操作如 containAll 等的原子性,即批量操作是线程不安全的)

HashMap,TreeMap -> ConcureentHashMap,ConcurrentSkipListMap

#### AbstractQueuedSynchronizer - AQS

![](/images/AQS.jpg)

使用 Node 实现 FIFO 队列,可以用于构建锁或者其他同步装置的基础框架

利用了一个 int 类型表示状态

使用方法是继承,子类通过继承并通过实现它 的方法管理其状态{acquire 和 release}的方法是操纵状态

可以同时实现排它锁和共享锁模式(独占,共享)

##### AQS 同步组件

CountDownLatch (通过计数来表示线程是否需要一直阻塞)

Semaphore (控制同一时间想承包并发的数目)

CycliBarrier

ReentrantLock

Condition

FutureTask

...
